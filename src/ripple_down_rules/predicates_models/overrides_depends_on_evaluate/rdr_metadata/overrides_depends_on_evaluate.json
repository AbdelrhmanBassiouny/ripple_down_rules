{
    "_type": "ripple_down_rules.rdr.GeneralRDR",
    "start_rules": {
        "output_": {
            "_type": "ripple_down_rules.rdr.SingleClassRDR",
            "start_rule": {
                "_type": "ripple_down_rules.rules.SingleClassRule",
                "conditions": {
                    "_type": "ripple_down_rules.datastructures.callable_expression.CallableExpression",
                    "user_input": "def _get_value(case):\n        def conditions_for_depends_on_evaluate(cls_: Type[DependsOn], dependent: Type[TrackedObjectMixin], dependency: Type[TrackedObjectMixin], recursive: bool, **kwargs) -> bool:\n            \"\"\"Get conditions on whether it's possible to conclude a value for depends_on_evaluate.output_  of type .\"\"\"\n            return (isinstance(dependent, type) and isinstance(dependency, type) and\n                    issubclass(dependent, TrackedObjectMixin) and issubclass(dependency, TrackedObjectMixin))\n        return conditions_for_depends_on_evaluate(**case)\n    ",
                    "conclusion_type": [
                        "builtins.bool"
                    ],
                    "scope": {
                        "TrackedObjectMixin": "ripple_down_rules.datastructures.tracked_object.TrackedObjectMixin",
                        "Type": "typing.Type",
                        "DependsOn": "ripple_down_rules_meta.overrides.DependsOn"
                    },
                    "conclusion": {
                        "_type": "builtins.NoneType",
                        "value": null
                    },
                    "mutually_exclusive": true
                },
                "conclusion": {
                    "_type": "ripple_down_rules.datastructures.callable_expression.CallableExpression",
                    "user_input": "def _get_value(case):\n        def depends_on_evaluate(cls_: Type[DependsOn], dependent: Type[TrackedObjectMixin], dependency: Type[TrackedObjectMixin], recursive: bool, **kwargs) -> bool:\n            \"\"\"Get possible value(s) for depends_on_evaluate.output_  of type .\"\"\"\n            return has(owner_type=dependent, member_type=dependency, recursive=recursive)\n        return depends_on_evaluate(**case)\n    ",
                    "conclusion_type": [
                        "builtins.bool"
                    ],
                    "scope": {
                        "TrackedObjectMixin": "ripple_down_rules.datastructures.tracked_object.TrackedObjectMixin",
                        "Type": "typing.Type",
                        "DependsOn": "ripple_down_rules_meta.overrides.DependsOn"
                    },
                    "conclusion": {
                        "_type": "builtins.NoneType",
                        "value": null
                    },
                    "mutually_exclusive": true
                },
                "parent": null,
                "conclusion_name": "output_",
                "weight": "",
                "uid": "3929361033208322153670901849644072096",
                "refinement": null,
                "alternative": {
                    "_type": "ripple_down_rules.rules.SingleClassRule",
                    "conditions": {
                        "_type": "ripple_down_rules.datastructures.callable_expression.CallableExpression",
                        "user_input": "def _get_value(case):\n    def conditions_for_depends_on_evaluate(cls_: Type[DependsOn], dependent: Type[TrackedObjectMixin], dependency: Type[TrackedObjectMixin], recursive: bool, **kwargs) -> bool:\n        \"\"\"Get conditions on whether it's possible to conclude a value for depends_on_evaluate.output_  of type .\"\"\"\n        return isinstance(dependent, Rule) and isinstance(dependency, Rule)\n    return conditions_for_depends_on_evaluate(**case)\n    ",
                        "conclusion_type": [
                            "builtins.bool"
                        ],
                        "scope": {
                            "TrackedObjectMixin": "ripple_down_rules.datastructures.tracked_object.TrackedObjectMixin",
                            "Rule": "ripple_down_rules.rules.Rule",
                            "Type": "typing.Type",
                            "dependent": "test.datasets.Cabinet",
                            "dependency": "test.datasets.Drawer",
                            "DependsOn": "ripple_down_rules_meta.overrides.DependsOn"
                        },
                        "conclusion": {
                            "_type": "builtins.NoneType",
                            "value": null
                        },
                        "mutually_exclusive": true
                    },
                    "conclusion": {
                        "_type": "ripple_down_rules.datastructures.callable_expression.CallableExpression",
                        "user_input": "def _get_value(case):\n    def depends_on_evaluate(cls_: Type[DependsOn], dependent: Type[TrackedObjectMixin],\n                            dependency: Type[TrackedObjectMixin], recursive: bool, **kwargs) -> bool:\n        \"\"\"Get possible value(s) for depends_on_evaluate.output_  of type .\"\"\"\n        return any(dependsOn(dependent_ct, dependency_ct) for dependent_ct in dependent.conclusion.conclusion_type for\n                   dependency_ct in dependency.conclusion.conclusion_type if\n                   issubclass(dependent_ct, TrackedObjectMixin) and issubclass(dependency_ct,\n                                                                               TrackedObjectMixin))\n    return depends_on_evaluate(**case)\n    ",
                        "conclusion_type": [
                            "builtins.bool"
                        ],
                        "scope": {
                            "TrackedObjectMixin": "ripple_down_rules.datastructures.tracked_object.TrackedObjectMixin",
                            "Type": "typing.Type",
                            "dependent": "test.datasets.Cabinet",
                            "dependency": "test.datasets.Drawer",
                            "DependsOn": "ripple_down_rules_meta.overrides.DependsOn"
                        },
                        "conclusion": {
                            "_type": "builtins.NoneType",
                            "value": null
                        },
                        "mutually_exclusive": true
                    },
                    "parent": null,
                    "conclusion_name": null,
                    "weight": "else if",
                    "uid": "114740124515448400708123236287653930408",
                    "refinement": null,
                    "alternative": null
                }
            },
            "generated_python_file_name": "depends_on_evaluate_output__scrdr",
            "name": "output_",
            "case_type": "typing.Dict",
            "case_name": "depends_on_evaluate"
        }
    },
    "generated_python_file_name": "depends_on_evaluate_rdr",
    "name": "output_",
    "case_type": "typing.Dict",
    "case_name": "depends_on_evaluate"
}